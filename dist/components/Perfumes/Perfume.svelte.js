import './Perfume.svelte.css';
/* src/components/Perfumes/Perfume.svelte generated by Svelte v3.32.3 */
import {
	SvelteComponent,
	append,
	attr,
	check_outros,
	create_component,
	destroy_component,
	detach,
	element,
	empty,
	group_outros,
	init,
	insert,
	mount_component,
	safe_not_equal,
	space,
	transition_in,
	transition_out
} from "../../../_snowpack/pkg/svelte/internal.js";

import IntersectionObserver from "../Image/IntersectionObserver.svelte.js";
import Content from "../Commons/Modal/Content.svelte.js";
import Modal from "../Commons/Modal/Modal.svelte.js";
import Image from "../Image/Image.svelte.js";
import density from "../../constants/density.json.proxy.js";

function create_if_block(ctx) {
	let image;
	let current;

	image = new Image({
			props: {
				src: /*source*/ ctx[0].img_url,
				alt: /*source*/ ctx[0].title
			}
		});

	return {
		c() {
			create_component(image.$$.fragment);
		},
		m(target, anchor) {
			mount_component(image, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const image_changes = {};
			if (dirty & /*source*/ 1) image_changes.src = /*source*/ ctx[0].img_url;
			if (dirty & /*source*/ 1) image_changes.alt = /*source*/ ctx[0].title;
			image.$set(image_changes);
		},
		i(local) {
			if (current) return;
			transition_in(image.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(image.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(image, detaching);
		}
	};
}

// (13:4) <IntersectionObserver once={true} let:intersecting>
function create_default_slot_1(ctx) {
	let if_block_anchor;
	let current;
	let if_block = /*intersecting*/ ctx[2] && create_if_block(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (/*intersecting*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*intersecting*/ 4) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

// (19:2) <Modal>
function create_default_slot(ctx) {
	let content;
	let current;

	content = new Content({
			props: {
				title: "자세히 보기",
				image: /*source*/ ctx[0].img_url,
				rows: [
					{
						title: "브랜드는?",
						content: [/*source*/ ctx[0].brand]
					},
					{
						title: "이름은?",
						content: [/*source*/ ctx[0].title]
					},
					{
						title: "출시된 시기는?",
						content: [
							/*source*/ ctx[0].launching_year > "0" && /*source*/ ctx[0].launching_month > "0"
							? `${/*source*/ ctx[0].launching_year}년 ${/*source*/ ctx[0].launching_month}월`
							: "정보가 부족해요!"
						]
					},
					{
						title: "확산력은?",
						content: [
							/*densityDesc*/ ctx[1]
							? /*densityDesc*/ ctx[1]
							: "정보가 부족해요!"
						]
					},
					// {
					//   title: "이 향수와 어울리는 성별은?",
					//   content: [
					//     source.gender === "Feminine"
					//       ? "여성"
					//       : source.gender === "Shared"
					//       ? "중성"
					//       : "남성",
					//   ],
					// },
					{
						title: "향기 계열은?",
						content: /*source*/ ctx[0].main_scent.length > 0 || /*source*/ ctx[0].sub_scent.length > 0
						? [.../*source*/ ctx[0].main_scent, .../*source*/ ctx[0].sub_scent]
						: ["정보가 부족해요!"]
					},
					{
						title: "탑 노트는?",
						content: /*source*/ ctx[0].top_main || /*source*/ ctx[0].top_sub.length > 0
						? [/*source*/ ctx[0].top_main, .../*source*/ ctx[0].top_sub]
						: ["정보가 부족해요!"]
					},
					{
						title: "미들 노트는?",
						content: /*source*/ ctx[0].middle_main || /*source*/ ctx[0].middle_sub.length > 0
						? [/*source*/ ctx[0].middle_main, .../*source*/ ctx[0].middle_sub]
						: ["정보가 부족해요!"]
					},
					{
						title: "베이스 노트는?",
						content: /*source*/ ctx[0].base_main || /*source*/ ctx[0].base_sub.length > 0
						? [/*source*/ ctx[0].base_main, .../*source*/ ctx[0].base_sub]
						: ["정보가 부족해요!"]
					}
				]
			}
		});

	return {
		c() {
			create_component(content.$$.fragment);
		},
		m(target, anchor) {
			mount_component(content, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const content_changes = {};
			if (dirty & /*source*/ 1) content_changes.image = /*source*/ ctx[0].img_url;

			if (dirty & /*source*/ 1) content_changes.rows = [
				{
					title: "브랜드는?",
					content: [/*source*/ ctx[0].brand]
				},
				{
					title: "이름은?",
					content: [/*source*/ ctx[0].title]
				},
				{
					title: "출시된 시기는?",
					content: [
						/*source*/ ctx[0].launching_year > "0" && /*source*/ ctx[0].launching_month > "0"
						? `${/*source*/ ctx[0].launching_year}년 ${/*source*/ ctx[0].launching_month}월`
						: "정보가 부족해요!"
					]
				},
				{
					title: "확산력은?",
					content: [
						/*densityDesc*/ ctx[1]
						? /*densityDesc*/ ctx[1]
						: "정보가 부족해요!"
					]
				},
				// {
				//   title: "이 향수와 어울리는 성별은?",
				//   content: [
				//     source.gender === "Feminine"
				//       ? "여성"
				//       : source.gender === "Shared"
				//       ? "중성"
				//       : "남성",
				//   ],
				// },
				{
					title: "향기 계열은?",
					content: /*source*/ ctx[0].main_scent.length > 0 || /*source*/ ctx[0].sub_scent.length > 0
					? [.../*source*/ ctx[0].main_scent, .../*source*/ ctx[0].sub_scent]
					: ["정보가 부족해요!"]
				},
				{
					title: "탑 노트는?",
					content: /*source*/ ctx[0].top_main || /*source*/ ctx[0].top_sub.length > 0
					? [/*source*/ ctx[0].top_main, .../*source*/ ctx[0].top_sub]
					: ["정보가 부족해요!"]
				},
				{
					title: "미들 노트는?",
					content: /*source*/ ctx[0].middle_main || /*source*/ ctx[0].middle_sub.length > 0
					? [/*source*/ ctx[0].middle_main, .../*source*/ ctx[0].middle_sub]
					: ["정보가 부족해요!"]
				},
				{
					title: "베이스 노트는?",
					content: /*source*/ ctx[0].base_main || /*source*/ ctx[0].base_sub.length > 0
					? [/*source*/ ctx[0].base_main, .../*source*/ ctx[0].base_sub]
					: ["정보가 부족해요!"]
				}
			];

			content.$set(content_changes);
		},
		i(local) {
			if (current) return;
			transition_in(content.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(content.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(content, detaching);
		}
	};
}

function create_fragment(ctx) {
	let div1;
	let div0;
	let intersectionobserver;
	let t;
	let modal;
	let current;

	intersectionobserver = new IntersectionObserver({
			props: {
				once: true,
				$$slots: {
					default: [
						create_default_slot_1,
						({ intersecting }) => ({ 2: intersecting }),
						({ intersecting }) => intersecting ? 4 : 0
					]
				},
				$$scope: { ctx }
			}
		});

	modal = new Modal({
			props: {
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			div1 = element("div");
			div0 = element("div");
			create_component(intersectionobserver.$$.fragment);
			t = space();
			create_component(modal.$$.fragment);
			attr(div0, "class", "p-2 image_wrap svelte-10wrenu");
			attr(div1, "class", "px-2 py-4");
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, div0);
			mount_component(intersectionobserver, div0, null);
			append(div1, t);
			mount_component(modal, div1, null);
			current = true;
		},
		p(ctx, [dirty]) {
			const intersectionobserver_changes = {};

			if (dirty & /*$$scope, source, intersecting*/ 13) {
				intersectionobserver_changes.$$scope = { dirty, ctx };
			}

			intersectionobserver.$set(intersectionobserver_changes);
			const modal_changes = {};

			if (dirty & /*$$scope, source*/ 9) {
				modal_changes.$$scope = { dirty, ctx };
			}

			modal.$set(modal_changes);
		},
		i(local) {
			if (current) return;
			transition_in(intersectionobserver.$$.fragment, local);
			transition_in(modal.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(intersectionobserver.$$.fragment, local);
			transition_out(modal.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);
			destroy_component(intersectionobserver);
			destroy_component(modal);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	
	let { source } = $$props;
	const densityDesc = density.find(density => density.type === source.density)?.description;

	$$self.$$set = $$props => {
		if ("source" in $$props) $$invalidate(0, source = $$props.source);
	};

	return [source, densityDesc];
}

class Perfume extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, { source: 0 });
	}
}

export default Perfume;