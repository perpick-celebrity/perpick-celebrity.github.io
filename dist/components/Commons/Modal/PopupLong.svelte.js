import './PopupLong.svelte.css';
/* src/components/Commons/Modal/PopupLong.svelte generated by Svelte v3.32.3 */
import {
	SvelteComponent,
	append,
	attr,
	create_component,
	destroy_component,
	destroy_each,
	detach,
	element,
	init,
	insert,
	mount_component,
	safe_not_equal,
	set_data,
	space,
	text,
	transition_in,
	transition_out
} from "../../../../_snowpack/pkg/svelte/internal.js";

import RoundedImage from "../../Image/RoundedImage.svelte.js";
import IntersectionObserver from "../../Image/IntersectionObserver.svelte.js";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[2] = list[i];
	return child_ctx;
}

// (10:4) <IntersectionObserver once={true} let:intersecting>
function create_default_slot(ctx) {
	let roundedimage;
	let current;

	roundedimage = new RoundedImage({
			props: {
				src: /*image*/ ctx[0],
				alt: "perfume_image"
			}
		});

	return {
		c() {
			create_component(roundedimage.$$.fragment);
		},
		m(target, anchor) {
			mount_component(roundedimage, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const roundedimage_changes = {};
			if (dirty & /*image*/ 1) roundedimage_changes.src = /*image*/ ctx[0];
			roundedimage.$set(roundedimage_changes);
		},
		i(local) {
			if (current) return;
			transition_in(roundedimage.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(roundedimage.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(roundedimage, detaching);
		}
	};
}

// (15:2) {#each rows as row}
function create_each_block(ctx) {
	let h2;
	let t0_value = /*row*/ ctx[2].title + "";
	let t0;
	let t1;
	let p;
	let t2_value = /*row*/ ctx[2].content.reduce(func) + "";
	let t2;
	let t3;
	let br;

	return {
		c() {
			h2 = element("h2");
			t0 = text(t0_value);
			t1 = space();
			p = element("p");
			t2 = text(t2_value);
			t3 = space();
			br = element("br");
			attr(h2, "class", "text-lg svelte-1iiz4i0");
			attr(p, "class", "text-sm text-purple-600 font-bold svelte-1iiz4i0");
		},
		m(target, anchor) {
			insert(target, h2, anchor);
			append(h2, t0);
			insert(target, t1, anchor);
			insert(target, p, anchor);
			append(p, t2);
			insert(target, t3, anchor);
			insert(target, br, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*rows*/ 2 && t0_value !== (t0_value = /*row*/ ctx[2].title + "")) set_data(t0, t0_value);
			if (dirty & /*rows*/ 2 && t2_value !== (t2_value = /*row*/ ctx[2].content.reduce(func) + "")) set_data(t2, t2_value);
		},
		d(detaching) {
			if (detaching) detach(h2);
			if (detaching) detach(t1);
			if (detaching) detach(p);
			if (detaching) detach(t3);
			if (detaching) detach(br);
		}
	};
}

function create_fragment(ctx) {
	let div1;
	let h10;
	let t1;
	let h11;
	let t3;
	let div0;
	let intersectionobserver;
	let t4;
	let br;
	let t5;
	let current;

	intersectionobserver = new IntersectionObserver({
			props: {
				once: true,
				$$slots: {
					default: [
						create_default_slot,
						({ intersecting }) => ({ 5: intersecting }),
						({ intersecting }) => intersecting ? 32 : 0
					]
				},
				$$scope: { ctx }
			}
		});

	let each_value = /*rows*/ ctx[1];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	return {
		c() {
			div1 = element("div");
			h10 = element("h1");
			h10.textContent = "ðŸŒº";
			t1 = space();
			h11 = element("h1");
			h11.textContent = "ì´ í–¥ìˆ˜ë¥¼ ì†Œê°œí•©ë‹ˆë‹¤!";
			t3 = space();
			div0 = element("div");
			create_component(intersectionobserver.$$.fragment);
			t4 = space();
			br = element("br");
			t5 = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(h10, "class", "text-lg svelte-1iiz4i0");
			attr(h11, "class", "text-lg  pt-4 svelte-1iiz4i0");
			attr(div0, "class", "w-full p-2 image_wrap my-0 mx-auto svelte-1iiz4i0");
			attr(div1, "class", "tracking-widest mb-3 text-center");
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, h10);
			append(div1, t1);
			append(div1, h11);
			append(div1, t3);
			append(div1, div0);
			mount_component(intersectionobserver, div0, null);
			append(div1, t4);
			append(div1, br);
			append(div1, t5);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div1, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			const intersectionobserver_changes = {};

			if (dirty & /*$$scope, image*/ 65) {
				intersectionobserver_changes.$$scope = { dirty, ctx };
			}

			intersectionobserver.$set(intersectionobserver_changes);

			if (dirty & /*rows*/ 2) {
				each_value = /*rows*/ ctx[1];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div1, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		i(local) {
			if (current) return;
			transition_in(intersectionobserver.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(intersectionobserver.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);
			destroy_component(intersectionobserver);
			destroy_each(each_blocks, detaching);
		}
	};
}

const func = (p, c) => `${p}, ${c}`;

function instance($$self, $$props, $$invalidate) {
	let { image } = $$props, { rows } = $$props;

	$$self.$$set = $$props => {
		if ("image" in $$props) $$invalidate(0, image = $$props.image);
		if ("rows" in $$props) $$invalidate(1, rows = $$props.rows);
	};

	return [image, rows];
}

class PopupLong extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, { image: 0, rows: 1 });
	}
}

export default PopupLong;