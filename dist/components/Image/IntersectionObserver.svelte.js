import './IntersectionObserver.svelte.css';
/* src/components/Image/IntersectionObserver.svelte generated by Svelte v3.32.3 */
import {
	SvelteComponent,
	attr,
	binding_callbacks,
	create_slot,
	detach,
	element,
	init,
	insert,
	safe_not_equal,
	transition_in,
	transition_out,
	update_slot
} from "../../../_snowpack/pkg/svelte/internal.js";

import { onMount } from "../../../_snowpack/pkg/svelte.js";
const get_default_slot_changes = dirty => ({ intersecting: dirty & /*intersecting*/ 1 });
const get_default_slot_context = ctx => ({ intersecting: /*intersecting*/ ctx[0] });

function create_fragment(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[8].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], get_default_slot_context);

	return {
		c() {
			div = element("div");
			if (default_slot) default_slot.c();
			attr(div, "class", "svelte-11dz0yj");
		},
		m(target, anchor) {
			insert(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			/*div_binding*/ ctx[9](div);
			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope, intersecting*/ 129) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[7], dirty, get_default_slot_changes, get_default_slot_context);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (default_slot) default_slot.d(detaching);
			/*div_binding*/ ctx[9](null);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { once = false } = $$props;
	let { top = 0 } = $$props;
	let { bottom = 0 } = $$props;
	let { left = 0 } = $$props;
	let { right = 0 } = $$props;
	let intersecting = false;
	let container;

	onMount(() => {
		if (typeof IntersectionObserver !== "undefined") {
			const rootMargin = `${bottom}px ${left}px ${top}px ${right}px`;

			const observer = new IntersectionObserver(entries => {
					$$invalidate(0, intersecting = entries[0].isIntersecting);

					if (intersecting && once) {
						observer.unobserve(container);
					}
				},
			{ rootMargin });

			observer.observe(container);
			return () => observer.unobserve(container);
		}

		// The following is a fallback for older browsers
		function handler() {
			const bcr = container.getBoundingClientRect();
			$$invalidate(0, intersecting = bcr.bottom + bottom > 0 && bcr.right + right > 0 && bcr.top - top < window.innerHeight && bcr.left - left < window.innerWidth);

			if (intersecting && once) {
				window.removeEventListener("scroll", handler);
			}
		}

		window.addEventListener("scroll", handler);
		return () => window.removeEventListener("scroll", handler);
	});

	function div_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			container = $$value;
			$$invalidate(1, container);
		});
	}

	$$self.$$set = $$props => {
		if ("once" in $$props) $$invalidate(2, once = $$props.once);
		if ("top" in $$props) $$invalidate(3, top = $$props.top);
		if ("bottom" in $$props) $$invalidate(4, bottom = $$props.bottom);
		if ("left" in $$props) $$invalidate(5, left = $$props.left);
		if ("right" in $$props) $$invalidate(6, right = $$props.right);
		if ("$$scope" in $$props) $$invalidate(7, $$scope = $$props.$$scope);
	};

	return [
		intersecting,
		container,
		once,
		top,
		bottom,
		left,
		right,
		$$scope,
		slots,
		div_binding
	];
}

class IntersectionObserver_1 extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance, create_fragment, safe_not_equal, {
			once: 2,
			top: 3,
			bottom: 4,
			left: 5,
			right: 6
		});
	}
}

export default IntersectionObserver_1;