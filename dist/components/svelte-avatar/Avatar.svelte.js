import './Avatar.svelte.css';
/* src/components/svelte-avatar/Avatar.svelte generated by Svelte v3.36.0 */
import {
	SvelteComponent,
	append,
	attr,
	detach,
	element,
	init,
	insert,
	listen,
	noop,
	null_to_empty,
	run_all,
	safe_not_equal
} from "../../../_snowpack/pkg/svelte/internal.js";

import { getRandomColor } from "./utils.js";

function create_else_block(ctx) {
	let div;

	return {
		c() {
			div = element("div");
			div.textContent = `${/*abbr*/ ctx[10]}`;
			attr(div, "class", "innerInitials svelte-1uy49j5");
		},
		m(target, anchor) {
			insert(target, div, anchor);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (28:2) {#if src && !imageFail}
function create_if_block(ctx) {
	let div;
	let img;
	let img_class_value;
	let img_src_value;
	let div_class_value;
	let mounted;
	let dispose;

	return {
		c() {
			div = element("div");
			img = element("img");
			attr(img, "alt", "");
			attr(img, "class", img_class_value = "" + (null_to_empty(`innerImage`) + " svelte-1uy49j5"));
			if (img.src !== (img_src_value = /*src*/ ctx[2])) attr(img, "src", img_src_value);
			attr(div, "class", div_class_value = "" + (null_to_empty(/*imageLoading*/ ctx[8] ? "imageLoading" : "") + " svelte-1uy49j5"));
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, img);

			if (!mounted) {
				dispose = [
					listen(img, "error", /*error_handler*/ ctx[15]),
					listen(img, "load", /*load_handler*/ ctx[16])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty & /*src*/ 4 && img.src !== (img_src_value = /*src*/ ctx[2])) {
				attr(img, "src", img_src_value);
			}

			if (dirty & /*imageLoading*/ 256 && div_class_value !== (div_class_value = "" + (null_to_empty(/*imageLoading*/ ctx[8] ? "imageLoading" : "") + " svelte-1uy49j5"))) {
				attr(div, "class", div_class_value);
			}
		},
		d(detaching) {
			if (detaching) detach(div);
			mounted = false;
			run_all(dispose);
		}
	};
}

function create_fragment(ctx) {
	let div;
	let div_style_value;

	function select_block_type(ctx, dirty) {
		if (/*src*/ ctx[2] && !/*imageFail*/ ctx[7]) return create_if_block;
		return create_else_block;
	}

	let current_block_type = select_block_type(ctx, -1);
	let if_block = current_block_type(ctx);

	return {
		c() {
			div = element("div");
			if_block.c();
			attr(div, "aria-label", /*name*/ ctx[1]);
			attr(div, "class", "wrapper svelte-1uy49j5");
			attr(div, "style", div_style_value = "" + (/*style*/ ctx[0] + "--borderRadius:" + (/*square*/ ctx[6] ? 0 : /*borderRadius*/ ctx[5]) + "; --size:" + /*size*/ ctx[4] + "; --bgColor:" + /*background*/ ctx[9] + ";\n    --src:" + /*src*/ ctx[2] + "; --textColor:" + /*textColor*/ ctx[3] + "; --abbrLength:" + /*abbrLength*/ ctx[11]));
		},
		m(target, anchor) {
			insert(target, div, anchor);
			if_block.m(div, null);
		},
		p(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx, dirty)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(div, null);
				}
			}

			if (dirty & /*name*/ 2) {
				attr(div, "aria-label", /*name*/ ctx[1]);
			}

			if (dirty & /*style, square, borderRadius, size, src, textColor*/ 125 && div_style_value !== (div_style_value = "" + (/*style*/ ctx[0] + "--borderRadius:" + (/*square*/ ctx[6] ? 0 : /*borderRadius*/ ctx[5]) + "; --size:" + /*size*/ ctx[4] + "; --bgColor:" + /*background*/ ctx[9] + ";\n    --src:" + /*src*/ ctx[2] + "; --textColor:" + /*textColor*/ ctx[3] + "; --abbrLength:" + /*abbrLength*/ ctx[11]))) {
				attr(div, "style", div_style_value);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div);
			if_block.d();
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let { style = "" } = $$props;
	let { name = "Avatar" } = $$props;
	let { initials = "D" } = $$props;
	let { src = "" } = $$props;
	let { bgColor = "lightGrey" } = $$props;
	let { textColor = "white" } = $$props;
	let { size = "50px" } = $$props;
	let { borderRadius = "50%" } = $$props;
	let { square = false } = $$props;
	let { randomBgColor = false } = $$props;
	const background = randomBgColor ? getRandomColor() : bgColor;
	const abbr = initials;

	// const abbr = initials || i(name);
	const abbrLength = abbr.length;

	let imageFail = false;
	let imageLoading = true;
	const error_handler = () => $$invalidate(7, imageFail = true);
	const load_handler = () => $$invalidate(8, imageLoading = false);

	$$self.$$set = $$props => {
		if ("style" in $$props) $$invalidate(0, style = $$props.style);
		if ("name" in $$props) $$invalidate(1, name = $$props.name);
		if ("initials" in $$props) $$invalidate(12, initials = $$props.initials);
		if ("src" in $$props) $$invalidate(2, src = $$props.src);
		if ("bgColor" in $$props) $$invalidate(13, bgColor = $$props.bgColor);
		if ("textColor" in $$props) $$invalidate(3, textColor = $$props.textColor);
		if ("size" in $$props) $$invalidate(4, size = $$props.size);
		if ("borderRadius" in $$props) $$invalidate(5, borderRadius = $$props.borderRadius);
		if ("square" in $$props) $$invalidate(6, square = $$props.square);
		if ("randomBgColor" in $$props) $$invalidate(14, randomBgColor = $$props.randomBgColor);
	};

	return [
		style,
		name,
		src,
		textColor,
		size,
		borderRadius,
		square,
		imageFail,
		imageLoading,
		background,
		abbr,
		abbrLength,
		initials,
		bgColor,
		randomBgColor,
		error_handler,
		load_handler
	];
}

class Avatar extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance, create_fragment, safe_not_equal, {
			style: 0,
			name: 1,
			initials: 12,
			src: 2,
			bgColor: 13,
			textColor: 3,
			size: 4,
			borderRadius: 5,
			square: 6,
			randomBgColor: 14
		});
	}
}

export default Avatar;