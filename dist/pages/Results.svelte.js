import './Results.svelte.css';
/* src/pages/Results.svelte generated by Svelte v3.32.3 */
import {
	SvelteComponent,
	append,
	attr,
	component_subscribe,
	create_component,
	destroy_component,
	detach,
	element,
	empty,
	handle_promise,
	init,
	insert,
	mount_component,
	noop,
	safe_not_equal,
	space,
	transition_in,
	transition_out
} from "../../_snowpack/pkg/svelte/internal.js";

import { users } from "../stores/index.js";
import API from "../api/perfumes.js";
import Celebrity from "../components/Celebrity/Celebrity.svelte.js";
import RecommendedPerfumes from "../components/Perfumes/RecommendedPerfumes.svelte.js";
import IntersectionObserver from "../components/Image/IntersectionObserver.svelte.js";
import { getCelebruty } from "../utils/PerfumeCalc/PerfumeCalc.js";

function create_if_block(ctx) {
	let await_block_anchor;
	let promise;
	let current;

	let info = {
		ctx,
		current: null,
		token: null,
		hasCatch: false,
		pending: create_pending_block,
		then: create_then_block,
		catch: create_catch_block,
		value: 3,
		blocks: [,,,]
	};

	handle_promise(promise = /*getPerfumes*/ ctx[1]({ match: [""], filter: { gender: "" } }), info);

	return {
		c() {
			await_block_anchor = empty();
			info.block.c();
		},
		m(target, anchor) {
			insert(target, await_block_anchor, anchor);
			info.block.m(target, info.anchor = anchor);
			info.mount = () => await_block_anchor.parentNode;
			info.anchor = await_block_anchor;
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			{
				const child_ctx = ctx.slice();
				child_ctx[3] = info.resolved;
				info.block.p(child_ctx, dirty);
			}
		},
		i(local) {
			if (current) return;
			transition_in(info.block);
			current = true;
		},
		o(local) {
			for (let i = 0; i < 3; i += 1) {
				const block = info.blocks[i];
				transition_out(block);
			}

			current = false;
		},
		d(detaching) {
			if (detaching) detach(await_block_anchor);
			info.block.d(detaching);
			info.token = null;
			info = null;
		}
	};
}

// (1:0) <script lang="ts">import { users }
function create_catch_block(ctx) {
	return {
		c: noop,
		m: noop,
		p: noop,
		i: noop,
		o: noop,
		d: noop
	};
}

// (27:2) {:then perfumes}
function create_then_block(ctx) {
	let intersectionobserver;
	let current;

	intersectionobserver = new IntersectionObserver({
			props: {
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(intersectionobserver.$$.fragment);
		},
		m(target, anchor) {
			mount_component(intersectionobserver, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const intersectionobserver_changes = {};

			if (dirty & /*$$scope*/ 16) {
				intersectionobserver_changes.$$scope = { dirty, ctx };
			}

			intersectionobserver.$set(intersectionobserver_changes);
		},
		i(local) {
			if (current) return;
			transition_in(intersectionobserver.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(intersectionobserver.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(intersectionobserver, detaching);
		}
	};
}

// (28:4) <IntersectionObserver>
function create_default_slot(ctx) {
	let div1;
	let div0;
	let celebrity_1;
	let div0_style_value;
	let t;
	let recommendedperfumes;
	let current;

	celebrity_1 = new Celebrity({
			props: { celebrity: /*celebrity*/ ctx[0] }
		});

	recommendedperfumes = new RecommendedPerfumes({
			props: { perfumes: /*perfumes*/ ctx[3].data }
		});

	return {
		c() {
			div1 = element("div");
			div0 = element("div");
			create_component(celebrity_1.$$.fragment);
			t = space();
			create_component(recommendedperfumes.$$.fragment);
			attr(div0, "style", div0_style_value = `background-color: ${"title.bg_color"}`);
			attr(div0, "class", "p-2 title_shadow svelte-127qi9n");
			attr(div1, "class", "pt-4 bg-white mb-4 shadow-lg m-4 rounded");
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, div0);
			mount_component(celebrity_1, div0, null);
			append(div1, t);
			mount_component(recommendedperfumes, div1, null);
			current = true;
		},
		p: noop,
		i(local) {
			if (current) return;
			transition_in(celebrity_1.$$.fragment, local);
			transition_in(recommendedperfumes.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(celebrity_1.$$.fragment, local);
			transition_out(recommendedperfumes.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);
			destroy_component(celebrity_1);
			destroy_component(recommendedperfumes);
		}
	};
}

// (19:63)      <div class="w-full h-full fixed block top-0 left-0 bg-pp-50 opacity-75 z-50">       <div class="h-full flex justify-center pb-4 flex-col items-center">         <svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">           <circle cx="50" cy="50" r="45" stroke="#FFC2D8" />         </svg>       </div>     </div>   {:then perfumes}
function create_pending_block(ctx) {
	let div1;

	return {
		c() {
			div1 = element("div");
			div1.innerHTML = `<div class="h-full flex justify-center pb-4 flex-col items-center"><svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg" class="svelte-127qi9n"><circle cx="50" cy="50" r="45" stroke="#FFC2D8" class="svelte-127qi9n"></circle></svg></div>`;
			attr(div1, "class", "w-full h-full fixed block top-0 left-0 bg-pp-50 opacity-75 z-50");
		},
		m(target, anchor) {
			insert(target, div1, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div1);
		}
	};
}

function create_fragment(ctx) {
	let if_block_anchor;
	let current;
	let if_block = /*celebrity*/ ctx[0] && create_if_block(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			if (/*celebrity*/ ctx[0]) if_block.p(ctx, dirty);
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let $users;
	component_subscribe($$self, users, $$value => $$invalidate(2, $users = $$value));
	
	let celebrity = getCelebruty($users.select.value);

	const getPerfumes = async ({ match, filter }) => {
		return API.getPerfumesWithCelebrity({ select: $users.select, match, filter });
	};

	return [celebrity, getPerfumes];
}

class Results extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, {});
	}
}

export default Results;